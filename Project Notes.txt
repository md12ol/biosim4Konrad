Minimally Viable Product
    >>	For the first goal we want to make it so that half of the creatures are classified as mice and half as cats
    >>	The mice would have the typical condition of needing to make it to one of the edges in order to reproduce
    >>	The cats would be able to kill and would have the condition that they need to kill a creature to reproduce
    >>	What would this require?
        >>	Enable killing
            >>	Make sure mice aren't able to kill
        >>	Add in the possibility of different types of creatures
            >>	Add in a parameter within the indiv class that keeps track of mice and cats
            >>  When generating the population
        >>	Mice NNs don't include the kill neuron
        >>	(Cats mights not have sufficient kill neurons in their initial population. If so we will need to ensure more (or all) cats include the kill neuron)
        >>	Modify the selection mechanism for cats to be that they killed something during the sim
        >>	Two separate new population generations: one for cats and one for mice
        >>	Add a parameter to cats so we know if they have killed something

Future goals
    >>	Pheromone released by mice that other mice can detect and follow
    >>	Cats also need to have come in contact with another cat to reproduce
    >>	Cats shouldn't be eating other cats
    >>	Mouse Changes
        >>	Mice need to have come in contact with another mouse to reproduce
        >>	Mice need to have eaten to reproduce
        >>	Add in food for mice
        >>	Neurons to detect food but only mice can have them?
    >>	Either modified neurons or new neurons that add in species information to the other sensors
    >>	Gender of the mice/cats

Notes
    >>	The entire population dies each generation
    >>  Gene Structure: each gene represents a single connection in the NN
        >>  1 bit: either from input sensory neuron (0) or an internal neuron (1)
        >>  7 bits: this number mod the number of neurons from the previous bit identifies the source neuron for the connection
        >>  1 bit: either to an output action neuron (0) or an internal neuron (1)
        >>  7 bits: this number mod the number of neurons from the previous bit identifies the destination neuron for the connection
        >>  16 bits: the weight of the connection (can be negative)
    >>  An individual's NN contains all possible neurons (21 sensory neurons, maxNumberNeurons internal neuron(s), and 11 action neurons) but only some have connections
        >>  Each neuron can have multiple outgoing and/or incoming connections depending on the genes in the genome
        >>  Only neurons with a string of connections that ends in an action are considered when deciding a agent's next action
    >>  Sensory neurons output a value in range [0,1] based on the environment (W), the individual (I), or a random value ( )
        >>  These are then sent via connection to internal and/or action neurons
    >>  Internal neurons calculate the sum of all inputs multiplied by the edge weights -> tanh function -> [-1,1]
        >>  Internal neurons are the only neurons with self-referential edges, storing the last output of the neuron for input at the next simulation step
    >>  Action neurons calculate the same sum as internal neurons -> tanh function -> [-1,1]
        >>  Non-movement neurons normalize this value to [0,1]
        >>  Movement neurons ...?
        >>  MOVE_X and MOVE_Y are used to accumulate the values of the movement neurons
        >>  MOVE_EAST, MOVE_WEST, MOVE_NORTH and MOVE_SOUTH can also have negative urges meaning they corresponded to their oppositite (e.g. negative MOVE_WEST is similar to positive MOVE_EAST)
        >>  MOVE_FORWARD and MOVE_REVERSE depend on the last movement and can also have negative values (e.g. negative MOVE_REVERSE is similar to positive MOVE_FORWARD)
        >>  MOVE_LEFT and MOVE_RIGHT rotate the coordinates depending on the last movement (e.g. x = 1.0, y = 1.0 -> x = -1.0 and y = 1.0 if actionLevel is 1.0)
            >>  they also are similar to their opposite, if the actionLevel is negative
            >>  the normalised coordinates get multiplied with the actionLevel in arbitrarily range
        >>  MOVE_RL seems to work exactly like MOVE_RIGHT

    >>  Most of the actions modify the environment (W) (e.g., moving an agent to a new position or killing another agent) but a few modify internal variables of the individuals (I) (e.g., set_responsiveness and set_longprobe_dist).
    >>  Multiple Actions can be triggered for a single step
        >>  But only one movement for a single step is possible (depends on accumulated sum of all movement urges)
        >>  Movement is done after all other actions
        >>  Movement probability also depends on the responsiveness (gets multiplied with the sum of movement urges to decide the probability of movement in direction x or y)
        >>  e.g. (5.0, 5.0) adjusted by hyperbolic tangent function to (1.0, 1.0) multiplied with responsiveness 0.6 results in 60% chance of moving east and north respectively

    >>  When individual's spawn, their NN gets created from their genome
        >>  first a set of referenced neuron number is created, to keep track of their outputs
        >>  internal neurons without outputs or which only feed themselves get removed
        >>  remaining neurons get renumbered sequentially starting with 0
    >>  During a single simulation step, the sums of the inputs for each action neuron get calculated
    >>  then they get converted to a probability between 0 and 1 to be executed
    >>  not all action neurons are probability-based (for example responsiveness is set depending on the hyperbolic tangent of the input sum)

    >>  Pragma Omp Commands enable parallelization of the simulator
        >>  #pragma omp parallel num_threads(p.numThreads) default(shared)
            >>  #pragma omp parallel num_threads(p.numThreads) creates a number of threads which are forked at the beginning and joined in the end of the region
            >>  default(shared) means, that each thread can access the variables in the parallel region
        >>  #pragma omp single means, that only one thread executes the code within the region (usually the first one that reaches it)
        >>  #pragma omp for schedule(auto)
            >>  #pragma omp for means, that multiple threads run different regions of the loop (e.g. Thread 1 runs iteration 0 to 5 and Thread 2 runs iteration 6 to 10)
            >>  OMP Implementation/Runtime uses schedule(auto) as hint, how to divide the iterations into contigous, non-empty subsets (chunks) and how to distribute the chunks to the threads
                >> in case auto, the compiler and/or runtime system decides the distribution

Stuff we Don't Understand
    >>  Pragma Omp Commands

January 30th 2026
    >>  Look into understanding the NN and how that generates action for the individual and explain this to Michael (see above)
    >>  Look into what each of the pragma omp commands do with respect to parallelization
    >>  Modify it so that there are two types of species
        >>  In the simulation make it so one is one colour and the other is a different colour
        >>  Level 2: have the colour gradient be different for the two species